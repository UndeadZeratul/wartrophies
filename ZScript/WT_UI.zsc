extend class WT_MainHandler
{
	enum WT_LiteHudColor
	{
		Element_Labels,
		Element_TotalKills,
		Element_GenocideRank,
		Element_PlayerRank,
		Element_WeaponName,
		Element_WeaponRank,
		Element_WeaponKills
	}

	// [Ace] Currently used for visibility toggles.
	enum WT_LiteHudVisibilityFlags
	{
		VF_TotalKills		= 1 << 0,
		VF_GenocideRank		= 1 << 1,
		VF_GenocideMedal	= 1 << 2,
		VF_PlayerRank		= 1 << 3,
		VF_PlayerExperience	= 1 << 4,
		VF_PlayerMedal		= 1 << 5,
		VF_Player_All		= VF_TotalKills | VF_GenocideRank | VF_GenocideMedal | VF_PlayerRank | VF_PlayerExperience | VF_PlayerMedal,

		VF_WeaponName		= 1 << 6,
		VF_WeaponRank		= 1 << 7,
		VF_WeaponKills		= 1 << 8,
		VF_WeaponMedals		= 1 << 9,
		VF_Weapon_All		= VF_WeaponName | VF_WeaponRank | VF_WeaponKills | VF_WeaponMedals
	}

	enum WT_ScorecardPages
	{
		Page_Main,
		Page_Weapons,
		Page_Monsters
	}

	enum WT_LiteHudStats
	{
		Stats_None,
		Stats_Player,
		Stats_Weapon,
		Stats_All
	}


	// --------------------------------------------------
	// MAIN
	// --------------------------------------------------

	private transient CVar ScorecardScale;
	private transient CVar BlackDisplay;

	private transient CVar LiteHudType;
	private transient CVar LiteHudOrientation;
	private transient CVar LiteHudScale;
	private transient CVar LiteHudOffsetX;
	private transient CVar LiteHudOffsetY;
	private transient CVar LiteHudColors[7];
	private transient CVar LiteHudAlpha;
	private transient CVar LiteHudVisibilityFlags;

	static const int XPReq[] = { 5000, 8500, 12500, 16000, 20000, 25000, 31000, 37000, 45000, 60000, 85000, 100000, 125000, 175000, 250000, 400000, 600000, 900000, 1150000, 1400000, 1900000, 2850000, 4000000, 5000000 };
	static const string XPRanks[] = { "Private 1st Class", "Corporal", "Sergeant", "Staff Sergeant", "Sergeant 1st Class", "Master Sergeant", "First Sergeant", "Sergeant Major", "Cmd. Sergeant Major", "Master Chief Sergeant", "2nd Lieutenant", "1st Lieutenant", "Captain", "Major", "Lieutenant Colonel", "Colonel", "Brigadier General", "Major General", "Lieutenant General", "General", "General of the Army", "Field Marshal", "Force Of Freedom", "Savior of Humanity" };
	const RankImagesPrefix = "RANK";

	static const int WeapKillReq[] = { 50, 100, 250, 400, 550, 700, 900, 1000, 1300, 1650, 2000, 2500, 3000, 4000, 5000, 6500, 8000, 10000, 12500, 15000, 20000, 25000 };
	static const string WeapRanks[] = { "Uninteresting", "Barely Threatening", "Slightly Scary", "Unfriendly", "Not Too Rough", "Plenty Hurtful", "Perfectly Ordinary", "Face-Gibbing", "Agitating", "Map-clearing", "Barbaric", "Megawad-purging", "Ultraviolent", "Absolutely Barbaric", "Nightmare-inducing", "Epic", "Legendary", "American", "id Select", "Hall's Custom", "Carmack's Prized", "Romero's Own" };

	static const int GenocideReqs[] = { 50, 100, 250, 500, 1000, 1500, 2500, 3500, 4500, 6000, 7500, 9000, 11111, 13333, 16666, 20000, 25000, 30000, 35000, 50000, 70000, 99999, 125000, 175000, 250000, 350000, 500000, 750000, 1000000 };
	static const string GenocideRanks[] = { "Innocent", "Craven", "Unbloodied", "Gun-shy", "Rank-and-file", "Basic Grunt", "Diablophobe", "Grave Digger", "Butcher", "Spree Killer", "Bounty Hunter", "Master Gunman", "Elite Warrior", "Mass Assassin", "Basically Mor'Ladim", "Ludicrous", "The Cleaner", "Psychopath", "Warlord", "Bloodthirsty", "Anti-Army Weapon", "Okuplok", "Unstoppable Force", "Carnage Elemental", "Grim Reaper", "Icon of Slay", "Death Incarnate", "Doomslayer", "Origin Exstinctum" };

	static const int WeaponNameLengths[] =
	{
		17, // [Ace] Weapon list in the main page.
		30, // [Ace] Weapon stats in the main page.
		30 // [Ace] Weapon page.
	};

	static const int MonsterNameLengths[] =
	{
		22, // [Ace] Monster name in the main page.
		36 // [Ace] Timmy Turner, my name is DougsDaleDimmaDaleDimmaDimmsDomeDoDiDomeDimmsDimmaDimmaDome, Owner of the DougDimmsDimmaDaleDimmsDomeDoDiDimmaDimmsDaleDimmaDimmsDaleDimmaDome. Also monster page.
	};

	static const int MaxListEntries[] =
	{
		11, // [Ace] Weapon and monster lists in the main page.
		27 // [Ace] Weapon and mosnter lists in their specialized page.
	};

	const KillsPerMedal = 3;
	const MedalsPerUpgrade = 3; // [Ace] This must be 2 or above!
	const MedalsPerLine = 11;
	const MedalTypesCount = 9;
	const LiteHudMaxStringWidth = 200; // [Ace] Size in pixels.
	const FontName = "STRPFNT";
	private transient ui int WeaponListSelIndex;
	private transient ui int FolderListSelIndex;
	private transient ui int SubPage;
	private transient ui bool AutoSelected;
	private transient ui bool InSearchMode;
	private transient ui string SearchFilter;
	private transient bool DrawUi;
	private transient ui int SelectedPage;

	// [Ace] Global cache. These are here so they don't get reset all the time. With some exceptions. Part of the memory leak patch. Also boosts performance.
	private transient ui Array<class<Weapon> > AvailableWeapons;
	private transient ui Array<class<Actor> > AvailableMonsters;
	private transient ui Array<class<Actor> > AllMonsters;

	private transient ui int TotalKillsAll;
	private transient ui int TotalKillsAvailable;
	private transient ui int WeaponKills; // [Ace] The total kills for the selected weapon.
	private transient ui Array<int> AvailableWeaponsKills; // [Ace] Total kills for each available weapon.
	private transient ui Array<int> MonsterKills; // [Ace] For the currently selected weapon.
	private transient ui Array<int> AllMonsterKills; // [Ace] For every monster, regardless of weapon.

	private transient ui int PlayerRank;
	private transient ui string PlayerRankString;
	private transient ui int WeaponRank;
	private transient ui string WeaponRankString;
	private transient ui int GenocideRank;
	private transient ui string GenocideRankString;

	override void RenderOverlay(RenderEvent e)
	{
		int LiteHud = LiteHudType.GetInt();

		int OriginalWidth = StatusBar.HorizontalResolution;
		int OriginalHeight = StatusBar.VerticalResolution;

		StatusBar.BeginHUD(1.0, true);

		// --------------- LITE HUD ---------------

		if (LiteHud > Stats_None && !DrawUi && !AutomapActive && GameState == GS_LEVEL)
		{
			double Alpha = LiteHudAlpha.GetFloat();
			double Scale = LiteHudScale.GetFloat();
			int VisiblityFlags = LiteHudVisibilityFlags.GetInt();

			// [Ace] Dividing because smaller numbers means bigger HUD.
			if (Scale > 0)
			{
				StatusBar.SetSize(StatusBar.RelTop, int(640 / Scale), int(480 / Scale));
			}

			vector2 PlayerStatsSize = (0, 0);

			if (LiteHud != Stats_Weapon && VisiblityFlags & VF_Player_All != 0)
			{
				PlayerStatsSize = DrawLiteHudPlayerStats(StatusBar, (2 + LiteHudOffsetX.GetInt(), 2 + LiteHudOffsetY.GetInt()), VisiblityFlags, Alpha);
			}

			// [Ace] Don't update available weapons if the weapon stats aren't visible. It'd be a waste of VM time.
			if (LiteHud != Stats_Player && VisiblityFlags & VF_Weapon_All != 0)
			{
				GetAvailableWeapons(AvailableWeapons);
				AutoSelectCurrentWeapon();
				class<Weapon> WeaponListSel = GetSelectedWeaponInList();

				if (WeaponListSel && WeaponListSel == ReadyWeapon)
				{
					vector2 Pos = (2, 2);

					switch(LiteHudOrientation.GetInt())
					{
						case 0: Pos.Y += PlayerStatsSize.Y; break;
						case 1: Pos.X += PlayerStatsSize.X; break;
					}

					DrawLiteHudWeaponStats(StatusBar, WeaponListSel, (Pos.X + LiteHudOffsetX.GetInt(), Pos.Y + LiteHudOffsetY.GetInt()), VisiblityFlags, Alpha);
				}
			}

			if (NeedsUpdating & Update_Lite)
			{
				SendNetworkEvent("WT_MarkUpdated", Update_Lite);
			}
		}

		// --------------- SCORECARD ---------------
		else if (DrawUi)
		{
			double Scale = ScorecardScale.GetFloat();
			if (Scale > 0)
			{
				StatusBar.SetSize(StatusBar.RelTop, int(480 / Scale), int(320 / Scale));
			}
			switch (SelectedPage)
			{
				case Page_Main:
					DrawScorecardMain(StatusBar);
					if (NeedsUpdating & Update_Scorecard_Main) SendNetworkEvent("WT_MarkUpdated", Update_Scorecard_Main);
					break;
				case Page_Weapons:
					DrawScorecardWeapons(StatusBar);
					if (NeedsUpdating & Update_Scorecard_Weapons) SendNetworkEvent("WT_MarkUpdated", Update_Scorecard_Weapons);
					break;
				case Page_Monsters:
					DrawScorecardMonsters(StatusBar);
					if (NeedsUpdating & Update_Scorecard_Monsters) SendNetworkEvent("WT_MarkUpdated", Update_Scorecard_Monsters);
					break;
			}
		}
		else
		{
			AutoSelected = false;
		}

		if (!AutomapActive && DisableSaving)
		{
			HUDFont mMainFont = HUDFont.Create(FontName);
			StatusBar.DrawString(mMainFont, "KILL SAVING DISABLED", (-2, 2), BaseStatusBar.DI_SCREEN_RIGHT_TOP | BaseStatusBar.DI_TEXT_ALIGN_RIGHT, Font.CR_RED);
		}

		// --------------- PRETEND WE WERE NEVER HERE ---------------

		StatusBar.BeginHUD(1.0, false);
		StatusBar.SetSize(StatusBar.RelTop, OriginalWidth, OriginalHeight);
	}

	// --------------------------------------------------------------
	// LITE HUD - PLAYER
	// --------------------------------------------------------------

	private ui vector2 DrawLiteHudPlayerStats(BaseStatusBar sbar, vector2 pos, int visFlags, double alpha)
	{
		HUDFont mMainFont = HUDFont.Create(FontName);
		vector2 TotalSize = (0, 0);

		Font fnt = FontName;
		int DI_TL = BaseStatusBar.DI_SCREEN_LEFT_TOP | BaseStatusBar.DI_ITEM_LEFT_TOP;
		int DI_TL_TEXT_LEFT = BaseStatusBar.DI_SCREEN_LEFT_TOP | BaseStatusBar.DI_TEXT_ALIGN_LEFT;
		int DI_TL_CENTER_TEXT_CENTER = BaseStatusBar.DI_SCREEN_LEFT_TOP | BaseStatusBar.DI_TEXT_ALIGN_CENTER;
		int DI_TL_CENTER_TEXT_RIGHT = BaseStatusBar.DI_SCREEN_LEFT_TOP | BaseStatusBar.DI_TEXT_ALIGN_RIGHT;

		if (NeedsUpdating & Update_Lite)
		{
			TotalKillsAll = GetTotalKillsForAllWeapons();
		}

		// Total kills.
		if (visFlags & VF_TotalKills)
		{
			string TotalKillsString = "\c["..GetColorForElement(Element_Labels).."]Total: \c["..GetColorForElement(Element_TotalKills).."]"..sbar.FormatNumber(TotalKillsAll, 1, 10).."\c-";
			sbar.DrawString(mMainFont, TotalKillsString, (pos.x, pos.y + TotalSize.Y), DI_TL_TEXT_LEFT, Font.CR_UNTRANSLATED, alpha);

			TotalSize.X = max(TotalSize.X, fnt.StringWidth(TotalKillsString));
			TotalSize.Y += 10;
		}

		// Genocide rank.
		[GenocideRank, GenocideRankString] = GetGenocideRank(TotalKillsAll);
		if (visFlags & VF_GenocideRank)
		{
			sbar.DrawString(mMainFont, GenocideRankString, (pos.x, pos.y + TotalSize.Y), DI_TL_TEXT_LEFT, Font.FindFontColor(GetColorForElement(Element_GenocideRank)), alpha);

			TotalSize.X = max(TotalSize.X, fnt.StringWidth(GenocideRankString));
			TotalSize.Y += 10;
		}

		// [Ace] Separates sections.
		if (visFlags & VF_GenocideRank || visFlags & VF_TotalKills)
		{
			TotalSize.Y += 4;
		}

		// Player rank & prestige.
		[PlayerRank, PlayerRankString] = GetPlayerRank();
		if (visFlags & VF_PlayerRank)
		{
			if (Prestige > 0)
			{
				sbar.DrawImage("PRSTIGE"..Prestige, (pos.x, pos.y + TotalSize.Y - 5), DI_TL, alpha);
			}
			sbar.DrawString(mMainFont, PlayerRankString, (Prestige > 0 ? pos.x + 12 : pos.x, pos.y + TotalSize.Y), DI_TL_TEXT_LEFT, Font.FindFontColor(GetColorForElement(Element_PlayerRank)), alpha);

			TotalSize.X = max(TotalSize.X, fnt.StringWidth(PlayerRankString));
			TotalSize.Y += 10;
		}

		// Player experience.
		if (visFlags & VF_PlayerExperience)
		{
			string ExperienceString = "\c["..GetColorForElement(Element_Labels).."]XP: \c["..GetColorForElement(Element_PlayerRank).."]"..sbar.FormatNumber(Experience, 1, 7).."\c-";
			sbar.DrawString(mMainFont, ExperienceString, (pos.x, pos.y + TotalSize.Y), DI_TL_TEXT_LEFT, Font.CR_UNTRANSLATED, alpha);

			TotalSize.X = max(TotalSize.X, fnt.StringWidth(ExperienceString));
			TotalSize.Y += 10;

			// Player experience for next level.
			string NextRankExp = PlayerRank < XPReq.Size() ? sbar.FormatNumber(XPReq[PlayerRank], 1, 7) : "-";
			string NextRankExpString = "\c["..GetColorForElement(Element_Labels).."]NX: \c["..GetColorForElement(Element_PlayerRank).."]"..NextRankExp.."\c-";
			sbar.DrawString(mMainFont, NextRankExpString, (pos.x, pos.y + TotalSize.Y), DI_TL_TEXT_LEFT, Font.CR_UNTRANSLATED, alpha);

			TotalSize.X = max(TotalSize.X, fnt.StringWidth(NextRankExpString));
			TotalSize.Y += 10;
		}

		// Player medal.
		if (visFlags & VF_PlayerMedal)
		{
			sbar.DrawImage("RANK"..(PlayerRank + 1), (pos.x + 2, pos.y + TotalSize.Y + 4), DI_TL, alpha);
			TotalSize.X = max(TotalSize.X, 35);
		}

		// Genocide medal.
		if (visFlags & VF_GenocideMedal)
		{
			sbar.DrawImage("GRANK"..GenocideRank, (pos.x + (visFlags & VF_PlayerMedal ? 44 : 4), pos.y + TotalSize.Y + 4), DI_TL, alpha);
			TotalSize.X = max(TotalSize.X, (visFlags & VF_PlayerMedal ? 70 : 35));
		}

		// [Ace] If any of the medals are present, bump the Y offset.
		if (visFlags & VF_PlayerMedal || visFlags & VF_GenocideMedal)
		{
			TotalSize.Y += 42;
		}

		// [Ace] Add a small gap after the player stats.
		TotalSize.Y += 2;
		TotalSize.X += 10;

		return TotalSize;
	}

	// --------------------------------------------------------------
	// LITE HUD - WEAPON
	// --------------------------------------------------------------

	private ui void DrawLiteHudWeaponStats(BaseStatusBar sbar, class<Weapon> wpn, vector2 pos, int visFlags, double alpha)
	{
		HUDFont mMainFont = HUDFont.Create(FontName);

		int DI_TL = BaseStatusBar.DI_SCREEN_LEFT_TOP | BaseStatusBar.DI_ITEM_LEFT_TOP;
		int DI_TL_TEXT_LEFT = BaseStatusBar.DI_SCREEN_LEFT_TOP | BaseStatusBar.DI_TEXT_ALIGN_LEFT;
		int DI_TL_CENTER_TEXT_CENTER = BaseStatusBar.DI_SCREEN_LEFT_TOP | BaseStatusBar.DI_TEXT_ALIGN_CENTER;
		int DI_TL_CENTER_TEXT_RIGHT = BaseStatusBar.DI_SCREEN_LEFT_TOP | BaseStatusBar.DI_TEXT_ALIGN_RIGHT;

		bool UseFolderView = LiteFolderView.GetInt();
		if (wpn && (NeedsUpdating & Update_Lite))
		{
			WeaponKills = GetKillsForWeapon(wpn.GetClassName(), UseFolderView);
		}
		double NextOffsetY = pos.y;

		// Weapon name.
		if (visFlags & VF_WeaponName)
		{
			Font fnt = FontName;
			BrokenLines MultilineName = fnt.BreakLines(GetWeaponName(wpn, UseFolderView), LiteHudMaxStringWidth);
			for (int i = 0; i < MultilineName.Count(); ++i)
			{
				NextOffsetY += 10 * i;
				sbar.DrawString(mMainFont, MultilineName.StringAt(i), (pos.x, NextOffsetY), DI_TL_TEXT_LEFT, Font.FindFontColor(GetColorForElement(Element_WeaponName)), alpha);
			}
			NextOffsetY += 10;
		}
		
		// Weapon rank.
		[WeaponRank, WeaponRankString] = GetWeaponRank(WeaponKills);
		if (visFlags & VF_WeaponRank)
		{
			sbar.DrawString(mMainFont, WeaponRankString, (pos.x, NextOffsetY), DI_TL_TEXT_LEFT, Font.FindFontColor(GetColorForElement(Element_WeaponRank)), alpha);
			NextOffsetY += 10;
		}

		if (visFlags & VF_WeaponName || visFlags & VF_WeaponRank)
		{
			NextOffsetY += 4;
		}

		if (visFlags & VF_WeaponKills)
		{
			// Weapon kills.
			sbar.DrawString(mMainFont, "K:", (pos.x, NextOffsetY), DI_TL_TEXT_LEFT, Font.FindFontColor(GetColorForElement(Element_Labels)), alpha);
			sbar.DrawString(mMainFont, sbar.FormatNumber(WeaponKills, 1, 6), (pos.x + 14, NextOffsetY), DI_TL_TEXT_LEFT, Font.FindFontColor(GetColorForElement(Element_WeaponKills)), alpha);
			NextOffsetY += 10;

			// Weapon kills for next level.
			string NextWeaponRankKills = WeaponRank < WeapKillReq.Size() ? sbar.FormatNumber(WeapKillReq[WeaponRank], 1, 6) : "-";
			sbar.DrawString(mMainFont, "NX:", (pos.x, NextOffsetY), DI_TL_TEXT_LEFT, Font.FindFontColor(GetColorForElement(Element_Labels)), alpha);
			sbar.DrawString(mMainFont, NextWeaponRankKills, (pos.x + 24, NextOffsetY), DI_TL_TEXT_LEFT, Font.FindFontColor(GetColorForElement(Element_WeaponRank)), alpha);
			NextOffsetY += 14;
		}

		// Weapon medals.
		if (visFlags & VF_WeaponMedals)
		{
			DrawWeaponMedals(WeaponKills, (pos.x, NextOffsetY), DI_TL, alpha);
		}
	}

	// --------------------------------------------------------------
	// SCORECARD - MAIN
	// --------------------------------------------------------------

	private ui void DrawScorecardMain(BaseStatusBar sbar)
	{
		HUDFont mMainFont = HUDFont.Create(FontName);

		int DI_CENTER = BaseStatusBar.DI_SCREEN_CENTER | BaseStatusBar.DI_ITEM_CENTER;
		int DI_TEXT_LEFT = BaseStatusBar.DI_SCREEN_CENTER | BaseStatusBar.DI_TEXT_ALIGN_LEFT;
		int DI_TEXT_CENTER = BaseStatusBar.DI_SCREEN_CENTER | BaseStatusBar.DI_TEXT_ALIGN_CENTER;
		int DI_TEXT_RIGHT = BaseStatusBar.DI_SCREEN_CENTER | BaseStatusBar.DI_TEXT_ALIGN_RIGHT;

		// --------------- MISCELLANEOUS ---------------

		if (!InSearchMode) GetAvailableWeapons(AvailableWeapons);

		// [Ace] Autoselect in the list your currently selected weapon in the world.
		if (!AutoSelected)
		{
			AutoSelectCurrentWeapon();
			AutoSelected = true;
		}

		// --------------- SHARED ---------------

		class<Weapon> WeaponListSel = GetSelectedWeaponInList();

		// --------------- GRAPHIC ---------------
		
		sbar.DrawImage(BlackDisplay.GetBool() ? "WTSTATPB" : "WTSTATPN", (0, 0.5), DI_CENTER); // [Ace] 0.5 because nearest neighbour scaling is not your friend.

		// --------------- MAIN STATS ---------------

		if (WeaponListSel && (NeedsUpdating & Update_Scorecard_Main))
		{
			TotalKillsAll = GetTotalKillsForAllWeapons();
			TotalKillsAvailable = GetTotalKillsForAvailableWeapons();
			WeaponKills = GetKillsForWeapon(WeaponListSel.GetClassName(), false);
		}

		// Total kills.
		sbar.DrawString(mMainFont, sbar.FormatNumber(TotalKillsAll, 1, 10), (-42, -84), DI_TEXT_RIGHT, Font.FindFontColor("WT_Old_Red"));

		// Genocide rank.
		[GenocideRank, GenocideRankString] = GetGenocideRank(TotalKillsAll);
		sbar.DrawString(mMainFont, GenocideRankString, (-223, -60), DI_TEXT_LEFT, Font.FindFontColor("WT_Old_FadedRed"));

		// Genocide medal.
		sbar.DrawImage("GRANK"..GenocideRank, (-206, 77), DI_CENTER);

		// Player rank.
		[PlayerRank, PlayerRankString] = GetPlayerRank();
		sbar.DrawString(mMainFont, PlayerRankString, (-223, -36), DI_TEXT_LEFT, Font.FindFontColor("WT_Old_DarkGreen"));

		// Player prestige.
		sbar.DrawImage("PRSTIGE"..Prestige, (-45, -32.5), DI_CENTER);

		// Player experience.
		sbar.DrawString(mMainFont, sbar.FormatNumber(Experience, 1, 7), (-139, -12), DI_TEXT_RIGHT, Font.FindFontColor("WT_Old_DarkGreen"));

		// Player experience for next level.
		string NextPlayerRankExp = PlayerRank < XPReq.Size() ? sbar.FormatNumber(XPReq[PlayerRank], 1, 7) : "-";
		sbar.DrawString(mMainFont, NextPlayerRankExp, (-42, -12), DI_TEXT_RIGHT, Font.FindFontColor("WT_Old_DarkGreen"));

		// Player medal.
		sbar.DrawImage("RANK"..(PlayerRank + 1), (-206, 28), DI_CENTER);

		// --------------- WEAPON LIST ---------------

		int WeaponPagesTotal = max(1, int(ceil(AvailableWeapons.Size() / double(MaxListEntries[0]))));
		int WeaponPage = WeaponListSelIndex / MaxListEntries[0];

		string Title = InSearchMode ? SearchFilter.."_" : (SearchFilter != "" ? SearchFilter : "All Weapons");
		sbar.DrawString(mMainFont, Title, (-174, 12), DI_TEXT_LEFT, Font.FindFontColor("WT_Old_FadedBrown"));
		sbar.DrawString(mMainFont, (WeaponPage + 1).."/"..WeaponPagesTotal, (-42, 12), DI_TEXT_RIGHT, Font.FindFontColor("WT_Old_FadedBrown"));

		for (int i = 0; MaxListEntries[0] * WeaponPage + i < AvailableWeapons.Size() && i < MaxListEntries[0]; ++i)
		{
			let CurrWeapon = AvailableWeapons[MaxListEntries[0] * WeaponPage + i];
			
			sbar.DrawString(mMainFont, GetTruncatedText(GetActorTag(CurrWeapon), WeaponNameLengths[0]), (-174, 36 + 9 * i), DI_TEXT_LEFT, WeaponListSel == CurrWeapon ? Font.FindFontColor("WT_Old_OrangeRed") : Font.FindFontColor("WT_Old_FadedBrown"));
		}

		// --------------- WEAPON STATS ---------------

		if (WeaponListSel)
		{
			// Weapon name.
			sbar.DrawString(mMainFont, GetTruncatedText(GetActorTag(WeaponListSel), WeaponNameLengths[1]), (-7, -132), DI_TEXT_LEFT, Font.FindFontColor("WT_Old_White"));

			// Weapon rank.
			[WeaponRank, WeaponRankString] = GetWeaponRank(WeaponKills);
			sbar.DrawString(mMainFont, WeaponRankString, (-7, -108), DI_TEXT_LEFT, Font.FindFontColor("WT_Old_Gold"));
			sbar.DrawString(mMainFont, WeaponRank.."/"..WeapRanks.Size(), (223, -108), DI_TEXT_RIGHT, Font.FindFontColor("WT_Old_Gold"));

			// Weapon kills.
			sbar.DrawString(mMainFont, sbar.FormatNumber(WeaponKills, 1, 6), (66, -84), DI_TEXT_RIGHT, Font.FindFontColor("WT_Old_Red"));

			// Weapon kills for next level.
			string NextWeaponRankKills = WeaponRank < WeapKillReq.Size() ? sbar.FormatNumber(WeapKillReq[WeaponRank], 1, 6) : "-";
			sbar.DrawString(mMainFont, NextWeaponRankKills, (152, -84), DI_TEXT_RIGHT, Font.FindFontColor("WT_Old_Gold"));

			// Weapon preference.
			sbar.DrawString(mMainFont, "P:", (167, -84), DI_TEXT_LEFT, Font.FindFontColor("WT_Old_FadedBrown"));
			double Pref = WeaponKills / double(TotalKillsAvailable) * 100;
			sbar.DrawString(mMainFont, (Pref < 100 ? String.Format("%.2f", Pref) : String.Format("%i", Pref)).."%", (223, -84), DI_TEXT_RIGHT, Font.FindFontColor("WT_Old_Grey"));

			// Weapon icon.
			string SpriteToDraw = "";
			TextureID Icon = GetDefaultByType(WeaponListSel).Icon;
			if (Icon.IsValid())
			{
				SpriteToDraw = TexMan.GetName(Icon);
			}
			else
			{
				// [Ace] Loops either until NextState is null or until it starts back from the beginning.
				State SpawnState = GetDefaultByType(WeaponListSel).SpawnState;
				State CurrState = SpawnState;
				for (int i = 0; i < 30 && CurrState != null; ++i)
				{
					string SpriteName = TexMan.GetName(CurrState.GetSpriteTexture(0));
					if (SpriteName != "TNT1A0")
					{
						SpriteToDraw = SpriteName;
						break;
					}
					CurrState = CurrState.NextState;
				}
			}
			
			// [Ace] Scale down sprites if they're too large to fit in the display.
			TextureID Img = TexMan.CheckForTexture(SpriteToDraw, TexMan.Type_Any);
			vector2 ImgSize;
			[ImgSize.x, ImgSize.y] = TexMan.GetSize(Img);
			vector2 Box = (ImgSize.X > 90 ? 90 : -1, ImgSize.Y > 56 ? 56 : -1);
			sbar.DrawImage(SpriteToDraw, (40, -33), DI_CENTER, 1.0, Box);

			// Weapon medals.
			DrawWeaponMedals(WeaponKills, (108, -53), DI_CENTER, 1.0);

			// --------------- MONSTER LIST & STATS ---------------

			sbar.DrawString(mMainFont, "Monsters", (-7, 12), DI_TEXT_LEFT, Font.FindFontColor("WT_Old_FadedBlue"));
			sbar.DrawString(mMainFont, "Kills", (224, 12), DI_TEXT_RIGHT, Font.FindFontColor("WT_Old_FadedBlue"));

			// [Ace] Filter the monsters and get all the necessary data for the selected weapon.
			if (NeedsUpdating & Update_Scorecard_Main)
			{
				GetMonstersForWeapon(WeaponListSel.GetClassName(), AvailableMonsters);
				MonsterKills.Clear();
				for (int i = 0; i < AvailableMonsters.Size(); ++i)
				{
					let CurrMonster = AvailableMonsters[i];
					MonsterKills.Push(GetKillsForMonster(WeaponListSel.GetClassName(), CurrMonster.GetClassName()));
				}
			}

			// [Ace] Then display them.
			sbar.DrawString(mMainFont, (SubPage + 1).."/"..GetPages(AvailableMonsters.Size(), MaxListEntries[0]), (160, 12), DI_TEXT_RIGHT, Font.FindFontColor("WT_Old_FadedBlue"));

			int StartIndex = MaxListEntries[0] * SubPage;
			int mRow = 0; // [Ace] Manually advance row so I don't have to do lots of modulus.
			for (int i = StartIndex; i < AvailableMonsters.Size() && mRow < MaxListEntries[0]; ++i)
			{
				let CurrMonster = AvailableMonsters[i];

				// Name.
				sbar.DrawString(mMainFont, GetTruncatedText(GetActorTag(CurrMonster), MonsterNameLengths[0]), (-7, 36 + 9 * mRow), DI_TEXT_LEFT, Font.FindFontColor("WT_Old_FadedBlue"));

				// Kills.
				sbar.DrawString(mMainFont, sbar.FormatNumber(MonsterKills[i], 1, 5), (224, 36 + 9 * mRow), DI_TEXT_RIGHT, Font.FindFontColor("WT_Old_FadedBlue"));
				
				mRow++;
			}
		}
	}

	// --------------------------------------------------------------
	// SCORECARD - WEAPONS
	// --------------------------------------------------------------

	private ui void DrawScorecardWeapons(BaseStatusBar sbar)
	{
		HUDFont mMainFont = HUDFont.Create(FontName);

		int DI_CENTER = BaseStatusBar.DI_SCREEN_CENTER | BaseStatusBar.DI_ITEM_CENTER;
		int DI_TEXT_LEFT = BaseStatusBar.DI_SCREEN_CENTER | BaseStatusBar.DI_TEXT_ALIGN_LEFT;
		int DI_TEXT_CENTER = BaseStatusBar.DI_SCREEN_CENTER | BaseStatusBar.DI_TEXT_ALIGN_CENTER;
		int DI_TEXT_RIGHT = BaseStatusBar.DI_SCREEN_CENTER | BaseStatusBar.DI_TEXT_ALIGN_RIGHT;

		// --------------- MISCELLANEOUS ---------------

		GetAvailableWeapons(AvailableWeapons);

		// --------------- GRAPHIC ---------------
		
		sbar.DrawImage(BlackDisplay.GetBool() ? "WTSTATWB" : "WTSTATWN", (0, 0.5), DI_CENTER);

		// --------------- WEAPON LIST & STATS ---------------

		// Labels.
		sbar.DrawString(mMainFont, "Weapons", (-173, -132), DI_TEXT_LEFT, Font.FindFontColor("WT_Old_FadedBrown"));
		sbar.DrawString(mMainFont, "Kills", (116, -132), DI_TEXT_RIGHT, Font.FindFontColor("WT_Old_FadedBrown"));
		sbar.DrawString(mMainFont, "Pref.", (174, -132), DI_TEXT_RIGHT, Font.FindFontColor("WT_Old_FadedBrown"));

		if (NeedsUpdating & Update_Scorecard_Weapons)
		{
			AvailableWeaponsKills.Clear();
			for (int i = 0; i < AvailableWeapons.Size(); ++i)
			{
				AvailableWeaponsKills.Push(GetKillsForWeapon(AvailableWeapons[i].GetClassName(), false));
			}
			TotalKillsAvailable = GetTotalKillsForAvailableWeapons();
		}

		// [Ace] Then display them.
		sbar.DrawString(mMainFont, (SubPage + 1).."/"..GetPages(AvailableWeapons.Size(), MaxListEntries[1]), (47, -132), DI_TEXT_RIGHT, Font.FindFontColor("WT_Old_FadedBrown"));

		int StartIndex = MaxListEntries[1] * SubPage;
		int mRow = 0; // [Ace] Manually advance row so I don't have to do lots of modulus.
		for (int i = StartIndex; i < AvailableWeapons.Size() && mRow < MaxListEntries[1]; ++i)
		{
			bool AlternateColor = i % 2;
			let CurrWeapon = AvailableWeapons[i];

			// Name.
			sbar.DrawString(mMainFont, GetTruncatedText(GetActorTag(CurrWeapon), WeaponNameLengths[2]), (-173, -107 + 9 * mRow), DI_TEXT_LEFT, Font.FindFontColor(AlternateColor ? "WT_Old_FadedBrownAlt" : "WT_Old_FadedBrown"));

			// Kills.
			sbar.DrawString(mMainFont, sbar.FormatNumber(AvailableWeaponsKills[i], 1, 5), (116, -107 + 9 * mRow), DI_TEXT_RIGHT, Font.FindFontColor(AlternateColor ? "WT_Old_FadedRedAlt" : "WT_Old_FadedRed"));

			// Preference.
			double Pref = AvailableWeaponsKills[i] / double(TotalKillsAvailable) * 100;
			sbar.DrawString(mMainFont, (Pref < 100 ? String.Format("%.2f", Pref) : String.Format("%i", Pref)).."%", (174, -107 + 9 * mRow), DI_TEXT_RIGHT, Font.FindFontColor("WT_Old_Grey"));

			mRow++;
		}
	}

	// --------------------------------------------------------------
	// SCORECARD - MONSTERS
	// --------------------------------------------------------------

	private ui void DrawScorecardMonsters(BaseStatusBar sbar)
	{
		HUDFont mMainFont = HUDFont.Create(FontName);

		int DI_CENTER = BaseStatusBar.DI_SCREEN_CENTER | BaseStatusBar.DI_ITEM_CENTER;
		int DI_TEXT_LEFT = BaseStatusBar.DI_SCREEN_CENTER | BaseStatusBar.DI_TEXT_ALIGN_LEFT;
		int DI_TEXT_CENTER = BaseStatusBar.DI_SCREEN_CENTER | BaseStatusBar.DI_TEXT_ALIGN_CENTER;
		int DI_TEXT_RIGHT = BaseStatusBar.DI_SCREEN_CENTER | BaseStatusBar.DI_TEXT_ALIGN_RIGHT;

		// --------------- MISCELLANEOUS ---------------

		GetAvailableWeapons(AvailableWeapons);

		// --------------- GRAPHIC ---------------
		
		sbar.DrawImage(BlackDisplay.GetBool() ? "WTSTATMB" : "WTSTATMN", (0, 0.5), DI_CENTER);

		// --------------- MONSTER LIST & STATS ---------------

		// Labels.
		sbar.DrawString(mMainFont, "Monsters", (-173, -132), DI_TEXT_LEFT, Font.FindFontColor("WT_Old_FadedBlue"));
		sbar.DrawString(mMainFont, "T. Kills", (174, -132), DI_TEXT_RIGHT, Font.FindFontColor("WT_Old_FadedBlue"));

		// [Ace] Filter the monsters and get all of them for all filtered weapons.
		if (NeedsUpdating & Update_Scorecard_Monsters)
		{
			GetAllMonsters(AvailableWeapons, AllMonsters);
			AllMonsterKills.Clear();
			for (int i = 0; i < AllMonsters.Size(); ++i)
			{
				let CurrMonster = AllMonsters[i];
				AllMonsterKills.Push(GetTotalKillsForMonster(AvailableWeapons, CurrMonster.GetClassName()));
			}
		}

		// [Ace] Then display them.
		sbar.DrawString(mMainFont, (SubPage + 1).."/"..GetPages(AllMonsters.Size(), MaxListEntries[1]), (110, -132), DI_TEXT_RIGHT, Font.FindFontColor("WT_Old_FadedBlue"));

		int StartIndex = MaxListEntries[1] * SubPage;
		int mRow = 0; // [Ace] Manually advance row so I don't have to do lots of modulus.
		for (int i = StartIndex; i < AllMonsters.Size() && mRow < MaxListEntries[1]; ++i)
		{
			bool AlternateColor = i % 2;
			let CurrMonster = AllMonsters[i];

			// Name.
			sbar.DrawString(mMainFont, GetTruncatedText(GetActorTag(CurrMonster), MonsterNameLengths[1]), (-173, -107 + 9 * mRow), DI_TEXT_LEFT, Font.FindFontColor(AlternateColor ? "WT_Old_FadedBlueAlt" : "WT_Old_FadedBlue"));

			// Kills.
			sbar.DrawString(mMainFont, sbar.FormatNumber(AllMonsterKills[i], 1, 5), (174, -107 + 9 * mRow), DI_TEXT_RIGHT, Font.FindFontColor(AlternateColor ? "WT_Old_FadedBlueAlt" : "WT_Old_FadedBlue"));

			mRow++;
		}
	}


	// --------------------------------------------------
	// SHARED
	// --------------------------------------------------

	private ui void AutoSelectCurrentWeapon()
	{
		for (int i = 0; i < AvailableWeapons.Size(); ++i)
		{
			if (AvailableWeapons[i] == ReadyWeapon)
			{
				WeaponListSelIndex = i;
				break;
			}
		}
	}

	// [Ace] If the list suddenly goes blank, reset the index to 0. It also prevents out-of-index exceptions if you've selected the last weapon in the list and apply a filter which will reduce the total count.
	private ui class<Weapon> GetSelectedWeaponInList()
	{
		if (AvailableWeapons.Size() > 0)
		{
			if (WeaponListSelIndex >= AvailableWeapons.Size())
			{
				WeaponListSelIndex = AvailableWeapons.Size() - 1;
			}
			return AvailableWeapons[WeaponListSelIndex];
		}

		WeaponListSelIndex = 0;
		return null;
	}

	private ui void DrawWeaponMedals(int kills, vector2 pos, int flags, double alpha)
	{
		int MedalCount[MedalTypesCount]; // [Ace] Each integer denotes how many medals of a given type there should be, starting at the highest type.
		int TotalNumberOfMedals = kills / KillsPerMedal; // [Ace] More precisely, total number of tier 1 medals.
		for (int i = MedalTypesCount; i > 0; --i)
		{
			// [Ace] I'm not going to remember how this works a week from now.
			int MedalsForThisType = TotalNumberOfMedals / int(MedalsPerUpgrade ** (i - 1));
			TotalNumberOfMedals -= MedalsForThisType * int(MedalsPerUpgrade ** (i - 1));

			MedalCount[MedalTypesCount - i] = MedalsForThisType;
		}

		int MedalsShown = 0;
		for (int i = 0; i < MedalTypesCount; ++i)
		{
			MedalsShown += MedalCount[i];
			for (int j = 0; j < MedalCount[i]; ++j)
			{
				// [Ace] I'm definitely not going to remember how this works. I hate maths.
				int XOffset = (j + (MedalsShown - MedalCount[i]));
				int TotalXOffset = 11 * (XOffset % (MedalsPerLine));
				int WStatsOffsetY = 15 * (XOffset / MedalsPerLine);
				StatusBar.DrawImage("WMEDAL"..(MedalTypesCount - i), (pos.x + TotalXOffset, pos.y + WStatsOffsetY), flags, alpha);
			}
		}
	}

	private ui void GetAvailableWeapons(out Array<class<Weapon> > arr)
	{
		arr.Clear();
		int WFilter = IWADWeaponFilter.GetInt();
		
		let it = DictionaryIterator.Create(WeaponStats);
		while (it.Next())
		{
			class<Weapon> wpn;
			class<WT_Weapon> wtWpn;
			wpn = it.Key();
			wtWpn = it.Key();

			// [Ace] If the weapon is an internal WT class, it's probably a compatibility class. Check if the required actor exists, i.e. the mod it belongs to is loaded. If not, don't bother adding to list.
			if (wtWpn)
			{
				string CheckedActorString = GetDefaultByType(wtWpn).CheckedActor;
				if (CheckedActorString != "")
				{
					class<Actor> CheckedActorClass;
					CheckedActorClass = CheckedActorString;
					if (!CheckedActorClass) continue;
				}
			}

			if (wpn)
			{
				int IwadType = GetIwadType(Search_Weapons, wpn);
				if ((WFilter == Filter_All || WFilter == IWadType || IwadType == Filter_None) && !InSearchMode && (SearchFilter == "" || GetActorTag(wpn).MakeLower().IndexOf(SearchFilter.MakeLower()) != -1))
				{
					arr.Push(wpn);
				}
			}
		}

		// [Ace] Sort it.
		for (int i = 0; i < arr.Size() - 1; ++i)
		{
			for (int j = i + 1; j < arr.Size(); ++j)
			{
				let CurrWeapon = GetDefaultByType(arr[i]);
				let NextWeapon = GetDefaultByType(arr[j]);

				// [Ace] Sort by numbers first, then by first letter if the numbers match.
				if (CurrWeapon.SlotNumber >= NextWeapon.SlotNumber || (CurrWeapon.SlotNumber == NextWeapon.SlotNumber && String.Format("%s", CurrWeapon.GetClassName()).ByteAt(0) >= String.Format("%s", NextWeapon.GetClassName()).ByteAt(0)))
				{
					let Swap = arr[i];
					arr[i] = arr[j];
					arr[j] = Swap;
				}
			}
		}
	}

	private ui void GetMonstersForWeapon(string weapon, out Array<class<Actor> > arr)
	{
		arr.Clear();
		int MFilter = IWADMonsterFilter.GetInt();

		let it = DictionaryIterator.Create(Dictionary.FromString(WeaponStats.At(weapon)));
		while (it.Next())
		{
			class<Actor> mon;
			mon = it.Key();
			if (mon)
			{
				int IwadType = GetIwadType(Search_Monsters, mon);
				if (MFilter == Filter_All || MFilter == IWadType || IwadType == Filter_None)
				{
					arr.Push(mon);
				}
			}
		}

		SortMonsterArray(arr);
	}

	private ui void GetAllMonsters(Array<class<Weapon> > wArr, out Array<class<Actor> > mArr)
	{
		mArr.Clear();
		int MFilter = IWADMonsterFilter.GetInt();

		for (int i = 0; i < wArr.Size(); ++i)
		{
			let it = DictionaryIterator.Create(Dictionary.FromString(WeaponStats.At(wArr[i].GetClassName())));
			while (it.Next())
			{
				class<Actor> mon;
				mon = it.Key();
				if (mon && mArr.Find(mon) == mArr.Size())
				{
					int IwadType = GetIwadType(Search_Monsters, mon);
					if (MFilter == Filter_All || MFilter == IWadType || IwadType == Filter_None)
					{
						mArr.Push(mon);
					}
				}
			}
		}

		SortMonsterArray(mArr);
	}

	private ui void SortMonsterArray(out Array<class<Actor> > mArr)
	{
		// [Ace] Yes. Bubble sort again.
		for (int i = 0; i < mArr.Size() - 1; ++i)
		{
			for (int j = i + 1; j < mArr.Size(); ++j)
			{
				let CurrMonster = GetDefaultByType(mArr[i]);
				let NextMonster = GetDefaultByType(mArr[j]);
				if (CurrMonster.Health >= NextMonster.Health)
				{
					let Swap = mArr[i];
					mArr[i] = mArr[j];
					mArr[j] = Swap;
				}
			}
		}
	}

	// --------------------------------------------------
	// INFORMATION
	// --------------------------------------------------

	private ui int, string GetGenocideRank(int kills) const
	{
		int GenRank = 0;
		string GenRankString = "Pacifist";
		for (int i = 0; i < GenocideReqs.Size(); ++i)
		{
			if (kills >= GenocideReqs[i])
			{
				GenRank = i + 1;
				GenRankString = GenocideRanks[i];
			}
		}

		return GenRank, GenRankString;
	}

	private ui int, string GetPlayerRank() const
	{
		int PlayerRank = 0;
		string PlayerRankString = "Private";
		for (int i = 0; i < XPReq.Size(); ++i)
		{
			if (Experience >= XPReq[i])
			{
				PlayerRank = i + 1;
				PlayerRankString = XPRanks[i];
			}
		}

		return PlayerRank, PlayerRankString;
	}

	private ui string GetWeaponName(class<Weapon> wpn, bool useFolder)
	{
		string WpnName = wpn.GetClassName();
		string WeaponFolder = FolderBindings.At(WpnName.MakeLower());
		return useFolder && WeaponFolder != "" ? WeaponFolder : GetActorTag(wpn);
	}

	private ui int, string GetWeaponRank(int kills) const
	{
		int WeaponRank = 0;
		string WeaponRankString = "Strange";
		for (int i = 0; i < WeapKillReq.Size(); ++i)
		{
			if (kills >= WeapKillReq[i])
			{
				WeaponRank = i + 1;
				WeaponRankString = WeapRanks[i];
			}
		}

		return WeaponRank, WeaponRankString;
	}

	private ui int GetKillsForWeapon(string weapon, bool useFolder) const
	{
		int TotalKills = 0;

		// [Ace] The folder the weapon belongs to.
		string WeaponFolder = FolderBindings.At(weapon.MakeLower());
		if (useFolder && WeaponFolder != "")
		{
			Array<class<Weapon> > WeaponsInFolder;
			GetWeaponsInFolder(WeaponFolder, WeaponsInFolder);

			for (int i = 0; i < WeaponsInFolder.Size(); ++i)
			{
				TotalKills += GetKillsForWeapon(WeaponsInFolder[i].GetClassName(), false);
			}
		}
		else
		{
			string Kills = WeaponStats.At(weapon);
			if (Kills != "")
			{
				let it = DictionaryIterator.Create(Dictionary.FromString(Kills)); 
				while(it.Next())
				{
					TotalKills += int(it.Value().ToDouble());
				}
			}
		}

		return TotalKills;
	}

	private ui int GetTotalKillsForAllWeapons() const
	{
		int TotalKills = 0;
		let it = DictionaryIterator.Create(WeaponStats);
		while (it.Next())
		{
			TotalKills += GetKillsForWeapon(it.Key(), false);
		}
		return TotalKills;
	}

	// [Ace] Used with weapon preference to only base the percentage on available weapons.
	private ui int GetTotalKillsForAvailableWeapons() const
	{
		int TotalKills = 0;
		let it = DictionaryIterator.Create(WeaponStats);
		while (it.Next())
		{
			class<Weapon> wpn = it.Key();
			if (AvailableWeapons.Find(wpn) != AvailableWeapons.Size())
			{
				TotalKills += GetKillsForWeapon(it.Key(), false);
			}
		}
		return TotalKills;
	}

	private ui int GetKillsForMonster(string weapon, string monster) const
	{
		let Monsters = Dictionary.FromString(WeaponStats.At(weapon));
		return int(Monsters.At(monster).ToDouble());
	}

	private ui int GetTotalKillsForMonster(Array<class<Weapon> > wArr, string monster) const
	{
		int TotalKills = 0;

		for (int i = 0; i < wArr.Size(); ++i)
		{
			Dictionary MonstersForWeapon = Dictionary.FromString(WeaponStats.At(wArr[i].GetClassName()));
			TotalKills += int(MonstersForWeapon.At(monster).ToDouble());
		}

		return TotalKills;
	}

	private ui int GetPages(int totalEntries, int maxEntries) const
	{
		return max(1, int(ceil(totalEntries / double(maxEntries))));
	}

	private ui string GetColorForElement(WT_LiteHudColor element)
	{
		int CvarValue = LiteHudColors[element].GetInt();
		if (CvarValue == 0)
		{
			switch(element)
			{
				case Element_Labels: return "WT_FadedBrown";
				case Element_TotalKills: return "WT_Red";
				case Element_GenocideRank: return "WT_FadedRed";
				case Element_PlayerRank: return "WT_DarkGreen";
				case Element_WeaponName: return "WT_White";
				case Element_WeaponRank: return "WT_Gold";
				case Element_WeaponKills: return "WT_Red";
			}
		}

		return StringTable.Localize("$HUD_COLOR_"..CvarValue); // [Ace] Invalid colors = black.
	}

	private ui string GetTruncatedText(string text, int length)
	{
		if (text.Length() > length)
		{
			string TruncatedName = text.Mid(0, length);
			TruncatedName.DeleteLastCharacter();
			if (TruncatedName.ByteAt(TruncatedName.Length() - 1) == 32)
			{
				TruncatedName.DeleteLastCharacter();
			}
			text = TruncatedName.."...";
		}

		return text;
	}

	// [Ace] Checks if there's a custom tag. If not, gets the tag. If no tag is present either, get class name.
	private ui string GetActorTag(class<Actor> a)
	{
		string Tag = GetDefaultByType(a).GetTag();
		string CustomTag = GetCustomTag(a);
		
		return CustomTag != "" ? CustomTag : Tag; // [Ace] Tag will be class name if it doesn't exist.
	}

	// --------------------------------------------------
	// INPUT
	// --------------------------------------------------

	override bool UiProcess(UiEvent e)
	{
		if ((e.Type == UiEvent.Type_KeyDown || e.Type == UiEvent.Type_KeyRepeat) && DrawUi)
		{
			if (!InSearchMode)
			{
				switch (e.KeyChar)
				{
					// [Ace] Cycle pages left.
					case UiEvent.Key_Left:
						if (--SelectedPage < 0) SelectedPage = Page_Monsters;
						SubPage = 0;
						S_StartSound("WT/ChangePage", CHAN_AUTO, CHANF_UI | CHANF_LOCAL);
						break;

					// [Ace] Cycle pages right.
					case UiEvent.Key_Right:
						++SelectedPage %= Page_Monsters + 1;
						SubPage = 0;
						S_StartSound("WT/ChangePage", CHAN_AUTO, CHANF_UI | CHANF_LOCAL);
						break;

					// [Ace] Move weapon selection up.
					case UiEvent.Key_Up:
						if (SelectedPage != Page_Main) break;
						WeaponListSelIndex = max(0, WeaponListSelIndex - 1);
						SubPage = 0;
						SendNetworkEvent("WT_MarkNotUpdated", Update_Scorecard_Main);
						S_StartSound("WT/SelectWeapon", CHAN_AUTO, CHANF_UI | CHANF_LOCAL);
						break;

					// [Ace] Move weapon selection down.
					case UiEvent.Key_Down:
						if (SelectedPage != Page_Main) break;
						WeaponListSelIndex = min(WeaponListSelIndex + 1, AvailableWeapons.Size() - 1);
						SubPage = 0;
						SendNetworkEvent("WT_MarkNotUpdated", Update_Scorecard_Main);
						S_StartSound("WT/SelectWeapon", CHAN_AUTO, CHANF_UI | CHANF_LOCAL);
						break;

					// [Ace] Previous monster page.
					case UiEvent.Key_PgUp:
						SubPage = max(0, SubPage - 1);
						S_StartSound("WT/ChangeSubPage", CHAN_AUTO, CHANF_UI | CHANF_LOCAL);
						break;

					// [Ace] Next monster page.
					case UiEvent.Key_PgDn:
						int TotalEntries = 1;
						int MaxEntries = 1;
						switch (SelectedPage)
						{
							case Page_Main:
								TotalEntries = AvailableMonsters.Size();
								MaxEntries = MaxListEntries[0];
								break;
							case Page_Weapons:
								TotalEntries = AvailableWeapons.Size();
								MaxEntries = MaxListEntries[1];
								break;
							case Page_Monsters:
								TotalEntries = AllMonsters.Size();
								MaxEntries = MaxListEntries[1];
								break;
						}

						SubPage = min(SubPage + 1, GetPages(TotalEntries, MaxEntries) - 1);
						S_StartSound("WT/ChangeSubPage", CHAN_AUTO, CHANF_UI | CHANF_LOCAL);
						break;

					// [Ace] Exit menu.
					case UiEvent.Key_Escape:
						SearchFilter = "";
						SendNetworkEvent("WT_ToggleUi");
						SendNetworkEvent("WT_MarkNotUpdated", Update_Lite);
						break;

					// [Ace] Enter search mode. Chars: Space
					case 32:
						if (SelectedPage != Page_Main) break;
						SearchFilter = "";
						InSearchMode = true;
						break;

					// [Ace] Clear filter.
					case UiEvent.Key_Backspace:
						SearchFilter = "";
						break;

					// [Ace] Upgrade prestige. Chars: 'p' or 'P'.
					// It really bothers me that I'm doing such logic checks in the UI. I'd have to completely mess up the scoping otherwise.
					case 80:
					case 112:
						if (GetPlayerRank() == XPRanks.Size() && Prestige < 3)
						{
							SendNetworkEvent("WT_UpgradePrestige");
						}
						break;

					// [Ace] Take screenshot.
					case UiEvent.Key_F12:
						LevelLocals.MakeScreenShot();
						break;
				}
			}
			else
			{
				switch (e.KeyChar)
				{
					// [Ace] Apply filter.
					case UiEvent.Key_Return:
						InSearchMode = false;
						break;

					// [Ace] Exit search mode and don't apply filter.
					case UiEvent.Key_Escape:
						SearchFilter = "";
						InSearchMode = false;
						break;

					// [Ace] Delete last character.
					case UiEvent.Key_Backspace:
						SearchFilter.DeleteLastCharacter();
						break;

					default:
						if (SearchFilter.Length() < 13)
						{
							SearchFilter = SearchFilter..e.KeyString;
						}
						break;
				}
			}
		}

		return false;
	}
}