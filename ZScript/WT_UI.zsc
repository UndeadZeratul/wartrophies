extend class WT_MainHandler
{
	// --------------------------------------------------
	// MAIN
	// --------------------------------------------------

	static const int XPReq[] = { 2500, 5000, 8000, 12500, 16000, 22000, 30000, 40000, 55000, 67500, 82000, 100000, 125000, 175000, 250000, 400000, 600000, 900000, 1150000, 1400000, 1900000, 2350000, 2850000, 3450000, 4000000, 5000000, 6500000, 8000000};
	static const string XPRanks[] = { "Private", "Private 1st Class", "Specialist", "Corporal", "Sergeant", "Staff Sergeant", "Sergeant 1st Class", "Master Sergeant", "First Sergeant", "Sergeant Major", "Cmd. Sergeant Major", "Master Chief Sergeant", "2nd Lieutenant", "1st Lieutenant", "Captain", "Major", "Lieutenant Colonel", "Colonel", "Brigadier General", "Major General", "Lieutenant General", "General", "General of the Army", "Field Marshal", "Force Of Freedom", "Savior of Humanity", "Immortal Demonslayer", "Heavenly Demiurge" };
	const RankImagesPrefix = "RANK";

	static const int WeapKillReq[] = { 10, 25, 50, 100, 150, 250, 375, 500, 750, 999, 1000, 1500, 2500, 5000, 7500, 7616, 8500, 10000, 14444, 19670, 30000 };
	static const string WeapRanks[] = { "Strange", "Uninteresting", "Common", "Vaguely Rough", "Slightly Dangerous", "Plenty Hurtful", "Heavily Damaging", "Blood Splattered", "Wicked", "Positively Demonic", "Absolutely Ordinary", "Face-Gibbing", "Death-Inducing", "Absolutely Barbaric", "Ultraviolent", "Nightmarish", "American", "iD Select", "Carmack's Own", "Ludicrously Deadly", "Romero's Prized"};

	static const int GenocideReqs[] = { 100, 500, 1500, 2750, 5500, 9000, 14000, 22000, 30000, 45000, 66666, 99999, 125000, 150000, 175000, 200000, 225000, 250000, 275000, 300000, 325000, 350000, 375000, 400000, 450000, 500000  };
	static const string GenocideRanks[]= { "Innocent", "Pacifist", "Gun-shy", "Unbloodied", "Still Afraid", "Base Grunt", "Bounty Hunter", "Grave Digger", "Ditch Filler", "Killer", "Murderous Spree", "Mass Assassin", "Master Gunman", "Basically Mor' Ladim", "Anti-Army", "Diablophobe", "Bloodthirsty", "Ludicrous", "Warlord", "The Cleaner", "Psychopath", "Unstoppable Force", "Carnage Elemental", "Death Incarnate", "Doomslayer", "God of Genocide" };

	const WeaponListEntries = 11;
	const WeaponListMaxStringWidth = 17;
	const MonsterListEntries = 11;
	const MonsterListMaxStringWidth = 15;
	const KillsPerMedal = 5;
	const MedalsPerUpgrade = 5;
	const MedalsPerLine = 11;
	const MedalTypesCount = 6;
	private transient ui int SelWeaponIndex;
	private transient ui int SelMonsterPage;
	private transient ui Array<class<Weapon> > AvailableWeapons;
	private transient ui Array<class<Actor> > AvailableMonsters;
	private transient bool DrawUi;

	private transient ui HUDFont mMainFont;

	override void RenderOverlay(RenderEvent e)
	{
		if (DrawUi)
		{
			int DI_CENTER = BaseStatusBar.DI_SCREEN_CENTER | BaseStatusBar.DI_ITEM_CENTER;
			int DI_TEXT_LEFT = BaseStatusBar.DI_SCREEN_CENTER | BaseStatusBar.DI_TEXT_ALIGN_LEFT;
			int DI_TEXT_CENTER = BaseStatusBar.DI_SCREEN_CENTER | BaseStatusBar.DI_TEXT_ALIGN_CENTER;
			int DI_TEXT_RIGHT = BaseStatusBar.DI_SCREEN_CENTER | BaseStatusBar.DI_TEXT_ALIGN_RIGHT;

			mMainFont = HUDFont.Create("STRPFNT");

			// [Ace] Mmmm, code injections!
			StatusBar.BeginHUD();

			// --------------- SHARED ---------------

			GetAvailableWeapons();
			GetAvailableMonsters();
			class<Weapon> SelWeapon;
			if (AvailableWeapons.Size() > 0)
			{
				SortWeaponList();
				if (SelWeaponIndex >= AvailableWeapons.Size())
				{
					SelWeaponIndex = AvailableWeapons.Size() - 1;
				}
				SelWeapon = AvailableWeapons[SelWeaponIndex];
			}
			else
			{
				SelWeaponIndex = 0;
			}

			// --------------- GRAPHIC ---------------
			
			StatusBar.DrawImage(BlackDisplay.GetBool() ? "WTSTATPB" : "WTSTATPN", (0, 0.5), DI_CENTER);

			// --------------- MAIN STATS ---------------

			int WeaponKills = SelWeapon ? GetKillsForWeapon(GetDefaultByType(SelWeapon).GetClassName()) : 0;
			int TotalKills = GetTotalKillsForAllWeapons();

			// Total kills.
			StatusBar.DrawString(mMainFont, StatusBar.FormatNumber(TotalKills, 1, 10), (-42, -84), DI_TEXT_RIGHT, Font.FindFontColor("WeaponKills"));

			// Genocide rank.
			string GenRank = "";
			for (int i = 0; i < GenocideReqs.Size(); ++i)
			{
				if (TotalKills >= GenocideReqs[i])
				{
					GenRank = GenocideRanks[i];
				}
			}
			StatusBar.DrawString(mMainFont, GenRank, (-223, -60), DI_TEXT_LEFT, Font.FindFontColor("WeaponKills"));

			// Player rank.
			int PlayerRank = 0;
			string PlayerRankString = "Recruit";
			for (int i = 0; i < XPReq.Size(); ++i)
			{
				if (Experience >= XPReq[i])
				{
					PlayerRank = i;
					PlayerRankString = XPRanks[i];
				}
			}
			StatusBar.DrawString(mMainFont, PlayerRankString, (-223, -36), DI_TEXT_LEFT, Font.FindFontColor("PlayerRank"));

			// Player experience.
			StatusBar.DrawString(mMainFont, StatusBar.FormatNumber(Experience, 1, 8), (-139, -12), DI_TEXT_RIGHT, Font.FindFontColor("PlayerRank"));

			// Player experience for next level.
			string NextPlayerRankExp = PlayerRank < XPReq.Size() - 1 ? StatusBar.FormatNumber(XPReq[PlayerRank + 1], 1, 8) : "-";
			StatusBar.DrawString(mMainFont, NextPlayerRankExp, (-42, -12), DI_TEXT_RIGHT, Font.FindFontColor("PlayerRank"));

			// Player medal.
			StatusBar.DrawImage("RANK"..PlayerRank, (-206, 28), DI_CENTER);

			// --------------- WEAPON LIST ---------------

			int WeaponPage = SelWeaponIndex / WeaponListEntries;
			for (int i = 0; WeaponListEntries * WeaponPage + i < AvailableWeapons.Size() && i < WeaponListEntries; ++i)
			{
				let CurrWeapon = GetDefaultByType(AvailableWeapons[WeaponListEntries * WeaponPage + i]);
				
				// [Ace] Truncate name if it's too long.
				string WeaponName = CurrWeapon.GetTag();
				if (WeaponName.Length() > WeaponListMaxStringWidth)
				{
					WeaponName = WeaponName.Mid(0, WeaponListMaxStringWidth).."...";
				}
				StatusBar.DrawString(mMainFont, WeaponName, (-174, 36 + 9 * i), DI_TEXT_LEFT, SelWeapon == CurrWeapon.GetClass() ? Font.FindFontColor("SelectedWeapon") : Font.FindFontColor("MiscLabels"));
			}

			// --------------- WEAPON STATS ---------------

			if (SelWeapon)
			{
				// Weapon name.
				StatusBar.DrawString(mMainFont, GetDefaultByType(SelWeapon).GetTag(), (-7, -132), DI_TEXT_LEFT, Font.FindFontColor("WeaponName"));

				// Weapon rank.
				int WeaponRank = 0;
				string WeaponRankString = "";
				for (int i = 0; i < WeapKillReq.Size(); ++i)
				{
					if (WeaponKills >= WeapKillReq[i])
					{
						WeaponRank = i + 1;
						WeaponRankString = WeapRanks[i];
					}
				}
				StatusBar.DrawString(mMainFont, WeaponRankString, (-7, -108), DI_TEXT_LEFT, Font.FindFontColor("WeaponRank"));
				StatusBar.DrawString(mMainFont, WeaponRank.."/"..WeapRanks.Size(), (223, -108), DI_TEXT_RIGHT, Font.FindFontColor("WeaponRank"));

				// Weapon kills.
				StatusBar.DrawString(mMainFont, StatusBar.FormatNumber(WeaponKills, 1, 6), (66, -84), DI_TEXT_RIGHT, Font.FindFontColor("WeaponKills"));

				// Weapon kills for next level.
				string NextWeaponRankKills = WeaponRank < WeapKillReq.Size() ? StatusBar.FormatNumber(WeapKillReq[WeaponRank], 1, 8) : "-";
				StatusBar.DrawString(mMainFont, NextWeaponRankKills, (152, -84), DI_TEXT_RIGHT, Font.FindFontColor("WeaponRank"));

				// Weapon preference.
				StatusBar.DrawString(mMainFont, int(WeaponKills / double(TotalKills) * 100).."%", (223, -84), DI_TEXT_RIGHT, Font.FindFontColor("WeaponPreference"));

				// Weapon icon.
				StatusBar.DrawImage(TexMan.GetName(GetDefaultByType(SelWeapon).SpawnState.GetSpriteTexture(0)), (40, -33), DI_CENTER);

				// Weapon medals.
				int MedalCount[MedalTypesCount]; // [Ace] Each integer denotes how many medals of a given type there should be, starting at the highest type.
				int TotalNumberOfMedals = WeaponKills / KillsPerMedal; // [Ace] More precisely, total number of tier 1 medals.
				for (int i = MedalTypesCount; i > 0; --i)
				{
					// [Ace] I'm not going to remember how this works a week from now.
					int MedalsForThisType = TotalNumberOfMedals / int(MedalsPerUpgrade ** (i - 1));
					TotalNumberOfMedals -= MedalsForThisType * int(MedalsPerUpgrade ** (i - 1));

					MedalCount[MedalTypesCount - i] = MedalsForThisType;
				}

				int MedalsShown = 0;
				for (int i = 0; i < MedalTypesCount; ++i)
				{
					MedalsShown += MedalCount[i];
					for (int j = 0; j < MedalCount[i]; ++j)
					{
						// [Ace] I'm definitely not going to remember how this works. I hate maths.
						int XOffset = (j + (MedalsShown - MedalCount[i]));
						int TotalXOffset = 11 * (XOffset % (MedalsPerLine));
						int YOffset = 15 * (XOffset / MedalsPerLine);
						StatusBar.DrawImage("WMEDAL"..(MedalTypesCount - i), (108 + TotalXOffset, -53 + YOffset), DI_CENTER);
					}
				}

				// --------------- MONSTER LIST & STATS ---------------

				// Display current monster page.
				StatusBar.DrawString(mMainFont, StatusBar.FormatNumber(SelMonsterPage, 1, 3), (116, 12), DI_TEXT_RIGHT, Font.FindFontColor("MonsterStats"));

				let MonDictIterator = DictionaryIterator.Create(Dictionary.FromString(MonsterKills.At(GetDefaultByType(SelWeapon).GetClassName())));
				int row = 0; // [Ace] The 'row' is used to manually advance the line.
				SortMonsterList();
				while (MonDictIterator.Next())
				{
					for (int i = 0; MonsterListEntries * SelMonsterPage + i < AvailableMonsters.Size() && i < MonsterListEntries; ++i)
					{
						if (MonDictIterator.Key() == AvailableMonsters[i].GetClassName())
						{
							let CurrMonster = GetDefaultByType(AvailableMonsters[MonsterListEntries * SelMonsterPage + i]);

							// [Ace] Truncate name if it's too long.
							string MonsterName = CurrMonster.GetTag();
							if (MonsterName.Length() > MonsterListMaxStringWidth)
							{
								MonsterName = MonsterName.Mid(0, MonsterListMaxStringWidth).."...";
							}
							StatusBar.DrawString(mMainFont, MonsterName, (-7, 36 + 9 * row), DI_TEXT_LEFT, Font.FindFontColor("MonsterStats"));

							// Kills.
							StatusBar.DrawString(mMainFont, MonDictIterator.Value(), (180, 36 + 9 * row), DI_TEXT_RIGHT, Font.FindFontColor("MonsterStats"));

							// Percentage compared to other kills.
							int Percentage = int(double(GetKillsForMonster(GetDefaultByType(SelWeapon).GetClassName(), CurrMonster.GetClassName())) / WeaponKills * 100);
							StatusBar.DrawString(mMainFont, Percentage.."%", (224, 36 + 9 * row), DI_TEXT_RIGHT, Font.FindFontColor("MonsterStats"));

							row++;
						}
					}
				}
			}
		}
	}

	// --------------------------------------------------
	// ARRAY OPERATIONS
	// --------------------------------------------------

	private ui void SortWeaponList()
	{
		for (int i = 0; i < AvailableWeapons.Size() - 1; ++i)
		{
			for (int j = i + 1; j < AvailableWeapons.Size(); ++j)
			{
				let CurrWeapon = GetDefaultByType(AvailableWeapons[i]);
				let NextWeapon = GetDefaultByType(AvailableWeapons[j]);

				// [Ace] Sort by numbers first, then by first letter if the numbers match.
				if (CurrWeapon.SlotNumber >= NextWeapon.SlotNumber || (CurrWeapon.SlotNumber == NextWeapon.SlotNumber && String.Format("%s", CurrWeapon.GetClassName()).ByteAt(0) >= String.Format("%s", NextWeapon.GetClassName()).ByteAt(0)))
				{
					let Swap = AvailableWeapons[i];
					AvailableWeapons[i] = AvailableWeapons[j];
					AvailableWeapons[j] = Swap;
				}
			}
		}
	}

	private ui void SortMonsterList()
	{
		for (int i = 0; i < AvailableMonsters.Size() - 1; ++i)
		{
			for (int j = i + 1; j < AvailableMonsters.Size(); ++j)
			{
				let CurrMonster = GetDefaultByType(AvailableMonsters[i]);
				let NextMonster = GetDefaultByType(AvailableMonsters[j]);
				if (CurrMonster.Health >= NextMonster.Health)
				{
					let Swap = AvailableMonsters[i];
					AvailableMonsters[i] = AvailableMonsters[j];
					AvailableMonsters[j] = Swap;
				}
			}
		}
	}

	private ui void GetAvailableWeapons()
	{
		AvailableWeapons.Clear();
		int Filter = IWADWeaponFilter.GetInt();

		let it = DictionaryIterator.Create(MonsterKills); 
		while (it.Next())
		{
			for (int i = 0; i < AllActorClasses.Size(); ++i)
			{
				class<Actor> a = AllActorClasses[i];
				if (a is "Weapon" && a.GetClassName() == it.Key())
				{
					bool IsFromIwad = IsIwadClass(Filter, Search_Weapons, a);
					if (Filter == Filter_All || Filter == Filter_None && !IsFromIwad || Filter > Filter_None && IsFromIwad)
					{
						AvailableWeapons.Push(a);
						break;
					}
				}
			}
		}
	}

	private ui void GetAvailableMonsters()
	{
		AvailableMonsters.Clear();
		int Filter = IWADMonsterFilter.GetInt();

		let it = DictionaryIterator.Create(MonsterKills);
		while (it.Next())
		{
			let it2 = DictionaryIterator.Create(Dictionary.FromString(it.Value()));
			while (it2.Next())
			{
				for (int i = 0; i < AllActorClasses.Size(); ++i)
				{
					// [Ace] The AvailableMonsters.Find check is here so that monsters aren't re-added by the next weapon.
					class<Actor> a = AllActorClasses[i];
					if (GetDefaultByType(a).bISMONSTER && a.GetClassName() == it2.Key() && AvailableMonsters.Find(a) == AvailableMonsters.Size())
					{
						bool IsFromIwad = IsIwadClass(Filter, Search_Monsters, a);
						if (Filter == Filter_All || Filter == Filter_None && !IsFromIwad || Filter > Filter_None && IsFromIwad)
						{
							AvailableMonsters.Push(a);
							break;
						}
					}
				}
			}
		}
	}

	// --------------------------------------------------
	// INFORMATION
	// --------------------------------------------------

	private ui int GetKillsForWeapon(string weapon) const
	{
		int TotalKills = 0;
		string Kills = MonsterKills.At(weapon);
		if (Kills != "")
		{
			let it = DictionaryIterator.Create(Dictionary.FromString(Kills)); 
			while(it.Next())
			{
				TotalKills += int(it.Value().ToDouble());
			}
		}

		return TotalKills;
	}

	private ui int GetTotalKillsForAllWeapons() const
	{
		int TotalKills = 0;
		let it = DictionaryIterator.Create(MonsterKills);
		{
			while (it.Next())
			{
				TotalKills += GetKillsForWeapon(it.Key());
			}
		}
		return TotalKills;
	}

	private ui int GetKillsForMonster(string weapon, string monster) const
	{
		let Monsters = Dictionary.FromString(MonsterKills.At(weapon));
		return int(Monsters.At(monster).ToDouble());
	}

	// --------------------------------------------------
	// INPUT
	// --------------------------------------------------

	override bool InputProcess(InputEvent e)
	{
		if (e.Type == InputEvent.Type_KeyDown && DrawUi)
		{
			// [Ace] Move weapon selection up.
			if (e.KeyScan == InputEvent.Key_UpArrow && SelWeaponIndex > 0)
			{
				SelWeaponIndex--;
				return true;
			}

			// [Ace] Move weapon selection down.
			GetAvailableWeapons(); // [Ace] Call it just in case.
			if (e.KeyScan == InputEvent.Key_DownArrow && SelWeaponIndex < AvailableWeapons.Size() - 1)
			{
				SelWeaponIndex++;
				return true;
			}

			// [Ace] Move monster selection up.
			if (e.KeyScan == InputEvent.Key_PgUp && SelMonsterPage > 0)
			{
				SelMonsterPage--;
				return true;
			}

			// [Ace] No cap on this because it'd be a pain to get how many pages the current weapon has.
			if (e.KeyScan == InputEvent.Key_PgDn)
			{
				SelMonsterPage++;
				return true;
			}
		}

		return false;
	}
}