extend class WT_MainHandler
{
	private CVar BlacklistEnabled;

	// [Ace] Works for both weapons and monsters. Inheritance is also taken into account.
	private Array<class<Actor> > BlacklistDefs;
	private Array<class<Actor> > WhitelistDefs;

	private bool IsValid(class<Actor> cls)
	{
		switch (BlackListEnabled.GetInt())
		{
			case 1:
			{
				for (int i = 0; i < BlacklistDefs.Size(); ++i)
				{
					if (cls is BlacklistDefs[i])
					{
						return false;
					}
				}
				return true;
			}
			case 2:
			{
				for (int i = 0; i < WhitelistDefs.Size(); ++i)
				{
					if (cls is WhitelistDefs[i])
					{
						return true;
					}
				}
				return false;
			}
		}
		return true;
	}

	// [Ace] Copy-pasted from Universal Gibs with some edits.
	override void OnRegister()
	{
		ParseLump("WTBLKLST", BlacklistDefs);
		ParseLump("WTWHTLST", WhitelistDefs);
	}

	private void ParseLump(string lumpName, out Array<class<Actor> > arr)
	{
		arr.Clear();
		int LumpNum = -1;
		while ((LumpNum = Wads.FindLump(lumpName, LumpNum + 1, Wads.GlobalNamespace)) >= 0)
		{
			string lumpText = Wads.ReadLump(LumpNum);
			lumpText.Replace("\n", "");
			lumpText.Replace("\r", "");
			lumpText.Replace(" ", "");

			Array<string> parsedList;
			lumpText.Split(parsedList, ",");

			for (int i = 0; i < parsedList.Size(); ++i)
			{
				string clsName = parsedList[i];

				// [Ace] The last character of the last element will be either end-of-line or some sort of an invisible termination character. It is added to the string as well, and that messes things up.
				clsName.StripRight();
				class<Actor> cls = clsName;
				if (cls && arr.Find(cls) == arr.Size())
				{
					arr.Push(cls);
				}
			}
		}
	}
}