class WT_MonsterInfo
{
	class<Actor> Cls;
	int Kills;
	int Percentage;
}

class WT_MainHandler : EventHandler
{
	enum IWADFilter
	{
		Filter_None,
		Filter_Doom,
		Filter_Heretic,
		Filter_Hexen,
		Filter_Strife,
		Filter_All
	}

	// --------------------------------------------------
	// CVARS & GLOBAL VARS
	// --------------------------------------------------

	private transient CVar WeaponStorage;
	private transient CVar ExperienceStorage;
	private transient CVar BlackDisplay;
	private transient CVar IWADWeaponFilter;
	private transient CVar IWADMonsterFilter;
	private transient CVar KillSoundType;
	private transient CVar LiteHUDType;

	private transient Array<class<Weapon> > AvailableWeapons;
	private transient Array<class<Actor> > AvailableMonsters;
	private int Experience;

	Dictionary MonsterKills; // [Ace] The value of each key is the monster dictionary's JSON. The key is the weapon.
	Dictionary ProjectileBinds; // [Ace] Key - projectile, value - weapon.

	private class<Weapon> ReadyWeapon;

	// --------------------------------------------------
	// FUNCTIONS
	// --------------------------------------------------

	void UpdateTallyFor(string weapon, string victim)
	{
		// [Ace] If weapon exists, update info.
		string CurrWeaponKills = MonsterKills.At(weapon);
		if (CurrWeaponKills != "")
		{
			Dictionary KillStats = Dictionary.FromString(CurrWeaponKills);

			string Kills = KillStats.At(victim);
			KillStats.Insert(victim, Kills != "" ? String.Format("%i", int(Kills.ToDouble()) + 1) : "1");

			MonsterKills.Insert(weapon, KillStats.ToString());
		}

		// [Ace] Otherwise, create it and update info.
		else
		{
			Dictionary KillStats = Dictionary.Create();
			KillStats.Insert(victim, "1");

			MonsterKills.Insert(weapon, KillStats.ToString());
		}
	}

	private void PlayKillSound()
	{
		S_StartSound("WT/KillSound"..KillSoundType.GetInt(), CHANF_UI, CHAN_AUTO | CHAN_UI);
	}

	private void SortWeaponList()
	{
		for (int i = 0; i < AvailableWeapons.Size() - 1; ++i)
		{
			for (int j = i + 1; j < AvailableWeapons.Size(); ++j)
			{
				let CurrWeapon = GetDefaultByType(AvailableWeapons[i]);
				let NextWeapon = GetDefaultByType(AvailableWeapons[j]);

				// [Ace] Sort by numbers first, then by first letter if the numbers match.
				if (CurrWeapon.SlotNumber >= NextWeapon.SlotNumber || (CurrWeapon.SlotNumber == NextWeapon.SlotNumber && String.Format("%s", CurrWeapon.GetClassName()).ByteAt(0) >= String.Format("%s", NextWeapon.GetClassName()).ByteAt(0)))
				{
					let Swap = AvailableWeapons[i];
					AvailableWeapons[i] = AvailableWeapons[j];
					AvailableWeapons[j] = Swap;
				}
			}
		}
	}

	private void GetAvailableActors()
	{
		AvailableWeapons.Clear();
		AvailableMonsters.Clear();

		int WFilter = IWADWeaponFilter.GetInt();
		int MFilter = IWADMonsterFilter.GetInt();

		let it = DictionaryIterator.Create(MonsterKills);
		while (it.Next())
		{
			// Weapons.
			for (int i = 0; i < AllActorClasses.Size(); ++i)
			{
				class<Actor> a = AllActorClasses[i];
				if (a is "Weapon" && a.GetClassName() == it.Key())
				{
					int IwadType = GetIwadType(Search_Weapons, a);
					if (WFilter == Filter_All || WFilter == IWadType || IwadType == Filter_None)
					{
						AvailableWeapons.Push(a);
						break;
					}
				}
			}

			// Monsters.
			let it2 = DictionaryIterator.Create(Dictionary.FromString(it.Value()));
			while (it2.Next())
			{
				for (int i = 0; i < AllActorClasses.Size(); ++i)
				{
					// [Ace] The AvailableMonsters.Find check is here so that monsters aren't re-added by the next weapon.
					class<Actor> a = AllActorClasses[i];
					if (GetDefaultByType(a).bISMONSTER && a.GetClassName() == it2.Key() && AvailableMonsters.Find(a) == AvailableMonsters.Size())
					{
						int IwadType = GetIwadType(Search_Monsters, a);
						if (MFilter == Filter_All || MFilter == IWadType || IwadType == Filter_None)
						{
							AvailableMonsters.Push(a);
							break;
						}
					}
				}
			}
		}

		SortWeaponList();
	}

	// --------------------------------------------------
	// DEATH STUFF
	// --------------------------------------------------

	// [Ace] WTD gets called *after* the damage is dealt. Just sayin'.
	// 10 bucks it's going to break with Hideous Destructor.
	// 20 bucks I won't be able to fix it.
	// 30 bucks I'm not paying up if I lose.
	override void WorldThingDamaged(WorldEvent e)
	{
		if (e.Thing && e.Thing.bISMONSTER && e.DamageSource && e.DamageSource is "PlayerPawn" && e.Thing.Health <= 0)
		{
			double FastMonstersMult = sv_fastmonsters || G_SkillPropertyInt(SKILLP_FastMonsters) ? 2.5 : 1;
			int SkillNumber = (G_SkillPropertyInt(SKILLP_ACSReturn) + 1);
			int ExperienceGained = int(min(10000, e.Thing.GetSpawnHealth()) * 0.05 * SkillNumber * FastMonstersMult);

			// [Ace] Killer is a projectile.
			if (e.Inflictor && e.Inflictor.bMISSILE)
			{
				string WeaponUsed = ProjectileBinds.At(e.Inflictor.GetClassName());
				if (WeaponUsed != "")
				{
					UpdateTallyFor(WeaponUsed, e.Thing.GetClassName());
					
					Experience += ExperienceGained;
					PlayKillSound();
				}
			}

			// [Ace] Killer is the player's hitscan.
			else
			{
				let plr = PlayerPawn(e.DamageSource);
				if (plr && plr.player && plr.player.ReadyWeapon)
				{
					string WeaponUsed = plr.player.ReadyWeapon.GetClassName();
					UpdateTallyFor(WeaponUsed, e.Thing.GetClassName());

					Experience += ExperienceGained;
					PlayKillSound();
				}
			}
		}
	}

	// --------------------------------------------------
	// PROJECTILE TO WEAPON ASSIGNMENT
	// --------------------------------------------------

	override void WorldThingSpawned(WorldEvent e)
	{
		if (e.Thing && e.Thing.bMISSILE && e.Thing.target && e.Thing.target is "PlayerPawn")
		{
			let plr = PlayerPawn(e.Thing.target);
			if (plr && plr.player && plr.player.ReadyWeapon)
			{
				ProjectileBinds.Insert(e.Thing.GetClassName(), plr.player.ReadyWeapon.GetClassName());
			}
		}
	}

	// --------------------------------------------------
	// INITIALIZATION
	// --------------------------------------------------

	override void OnRegister()
	{
		WeaponStorage = CVar.FindCVar('wt_stats_weapons_kills');
		ExperienceStorage = CVar.FindCVar('wt_stats_experience');
		BlackDisplay = CVar.FindCVar('wt_panel_blackdisplay');
		IWADWeaponFilter = CVar.FindCVar('wt_filter_iwad_weapons');
		IWADMonsterFilter = CVar.FindCVar('wt_filter_iwad_monsters');
		KillSoundType = CVar.FindCVar('wt_killsound');
		LiteHUDType = CVar.FindCVar('wt_showlite');
	}

	override void WorldLoaded(WorldEvent e)
	{
		Initialize(false);
	}

	void Initialize(bool reset)
	{
		ProjectileBinds = Dictionary.Create();

		// [Ace] This exists because calling ResetTally clears the CVars, but not before Dictionary.FromString can recreate the dictionary using the old CVars.
		// This forces creation of new dictionaries instead of relying on empty strings.
		if (reset)
		{
			WeaponStorage.ResetToDefault();
			ExperienceStorage.ResetToDefault();
			MonsterKills = Dictionary.Create();
			Experience = 0;
		}
		else
		{
			// [Ace] Glorious m8f hax. At least they actually work.
			String s = WeaponStorage.GetString();
			s.Replace("@", String.Format("%c", 92));
			MonsterKills = Dictionary.FromString(s);
			Experience = ExperienceStorage.GetInt();
		}
	}

	// --------------------------------------------------
	// VARIABLE UPDATES & OTHER
	// --------------------------------------------------

	override void WorldTick()
	{
		// [Ace] Increasing the delay might increase performance. Do it only if absolutely necessary!
		// There's no guarantee it will.
		if (level.time % 10 == 0)
		{
			SaveTally();

			GetAvailableActors();

			// [Ace] This will desync. You have been warned. I have been warned.
			let plr = PlayerPawn(players[consoleplayer].mo);
			if (plr && plr.player && plr.player.ReadyWeapon)
			{
				ReadyWeapon = plr.player.ReadyWeapon.GetClass();
			}
		}
	}

	private void SaveTally()
	{
		String s = MonsterKills.ToString();
		s.Replace(String.Format("%c", 92), "@");
		WeaponStorage.SetString(s);
		ExperienceStorage.SetInt(Experience);
	}

	// --------------------------------------------------
	// PROGRESS ERASING
	// --------------------------------------------------

	private void ResetTally()
	{
		Initialize(true);
		Console.Printf("Tally successfully reset!");
	}

	// --------------------------------------------------
	// MISCELLANEOUS
	// --------------------------------------------------

	override void NetworkProcess(ConsoleEvent e)
	{
		if (e.Name ~== "WT_ResetTally")
		{
			ResetTally();
		}

		if (e.Name ~== "WT_ToggleUI")
		{
			DrawUi = !DrawUi;
		}
	}
}