class WT_MainHandler : EventHandler
{
	enum WT_IwadFilter
	{
		Filter_None,
		Filter_Doom,
		Filter_Heretic,
		Filter_Hexen,
		Filter_Strife,
		Filter_All
	}

	enum WT_UpdateElement
	{
		Update_Lite					= 1,
		Update_Scorecard_Main		= 1 << 1,
		Update_Scorecard_Monsters	= 1 << 2,
		Update_All					= Update_Lite | Update_Scorecard_Main | Update_Scorecard_Monsters
	}

	// --------------------------------------------------
	// CVARS & GLOBAL VARS
	// --------------------------------------------------

	private transient int NeedsUpdating; // [Ace] Used to only update data when needed. This is here so the Lite HUD is also affected, as the only trigger for that is monster kills/weapon changes.

	private transient CVar WeaponStorage;
	private transient CVar ExperienceStorage;
	private transient CVar PrestigeStorage;

	private transient bool DisableSaving;
	private transient CVar KillSoundType;

	private transient int Experience;
	private transient int Prestige;

	// [Ace] I want to note, mainly to myself, that dictionaries are case-sensitive. Normally everything should Just Work(tm), but it may, and I mean ***MAY*** be possible for the planets to align and something to get fucked.
	// That's because I didn't know this at the time and didn't make everything lowercase. Not changing it now because people would lose progress. If something gets screwed up someday, I'll fix it. So far that hasn't happened.
	// Again, I underline that it MAY happen. Doesn't mean it WILL. MAY =/= WILL. Got it?

	private transient Dictionary WeaponStats; // [Ace] The value of each key is the monster dictionary's JSON. The key is the weapon.
	private transient Dictionary ProjectileBinds; // [Ace] Key - projectile, value - weapon.

	private transient class<Weapon> ReadyWeapon;

	// --------------------------------------------------
	// FUNCTIONS
	// --------------------------------------------------

	void UpdateTallyFor(string weapon, string victim)
	{
		// [Ace] If weapon exists, update info.
		string CurrWeaponKills = WeaponStats.At(weapon);
		if (CurrWeaponKills != "")
		{
			Dictionary KillStats = Dictionary.FromString(CurrWeaponKills);

			string Kills = KillStats.At(victim);
			KillStats.Insert(victim, Kills != "" ? String.Format("%i", int(Kills.ToDouble()) + 1) : "1");

			WeaponStats.Insert(weapon, KillStats.ToString());
		}

		// [Ace] Otherwise, create it and update info.
		else
		{
			Dictionary KillStats = Dictionary.Create();
			KillStats.Insert(victim, "1");

			WeaponStats.Insert(weapon, KillStats.ToString());
		}

		NeedsUpdating = Update_All;
	}

	private void PlayKillSound()
	{
		S_StartSound("WT/KillSound"..KillSoundType.GetInt(), CHAN_AUTO, CHANF_UI | CHANF_LOCAL);
	}

	private void UpgradePrestige()
	{
		Prestige++;
		int ExtraExperience = Experience - XPReq[XPReq.Size() - 1];
		Experience = ExtraExperience;
		S_StartSound("WT/Prestige", CHAN_AUTO, CHANF_UI | CHANF_LOCAL);
	}

	// --------------------------------------------------
	// DEATH STUFF
	// --------------------------------------------------

	// [Ace] WTD gets called *after* the damage is dealt. Just sayin'.
	// 10 bucks it's going to break with Hideous Destructor.
	// 20 bucks I won't be able to fix it.
	// 30 bucks I'm not paying up if I lose.
	override void WorldThingDamaged(WorldEvent e)
	{
		if (e.Thing && e.Thing.bISMONSTER && e.DamageSource && e.DamageSource is "PlayerPawn" && e.Thing.Health <= 0 && !IsBlacklisted(e.Thing.GetClass()))
		{
			double FastMonstersMult = sv_fastmonsters || G_SkillPropertyInt(SKILLP_FastMonsters) ? 2.5 : 1;
			int SkillNumber = min(4, (G_SkillPropertyInt(SKILLP_ACSReturn) + 1));
			int ExperienceGained = int(min(12000, e.Thing.default.Health) * 0.05 * SkillNumber * FastMonstersMult);

			// [Ace] Killer is a projectile that's also not a puff.
			if (e.Inflictor && e.Inflictor.bMISSILE && !e.Inflictor.bALWAYSPUFF && !e.Inflictor.bPUFFONACTORS)
			{
				string WeaponUsed = ProjectileBinds.At(e.Inflictor.GetClassName());
				if (WeaponUsed != "")
				{
					class<Actor> wpn = WeaponUsed;
					if (!IsBlacklisted(wpn))
					{
						UpdateTallyFor(WeaponUsed, e.Thing.GetClassName());
						
						Experience += ExperienceGained;
						PlayKillSound();
					}
				}
			}

			// [Ace] Killer is the player's hitscan or telefrag. Don't blacklist the telefrag.
			else
			{
				let plr = PlayerPawn(e.DamageSource);
				if (plr && e.DamageType == 'Telefrag')
				{
					UpdateTallyFor("WT_Telefrag", e.Thing.GetClassName());

					Experience += ExperienceGained;
					PlayKillSound();
				}
				else if (plr && ReadyWeapon && !IsBlacklisted(ReadyWeapon))
				{
					string WeaponUsed = ReadyWeapon.GetClassName();
					UpdateTallyFor(WeaponUsed, e.Thing.GetClassName());

					Experience += ExperienceGained;
					PlayKillSound();
				}
			}
		}
	}

	// --------------------------------------------------
	// PROJECTILE TO WEAPON ASSIGNMENT
	// --------------------------------------------------

	override void WorldThingSpawned(WorldEvent e)
	{
		// [Ace] Some mods' puffs have "+MISSILE". Don't consider them a projectile if they also have one of the puff flags.
		if (e.Thing && e.Thing.bMISSILE && !e.Thing.bALWAYSPUFF && !e.Thing.bPUFFONACTORS && e.Thing.target && e.Thing.target is "PlayerPawn")
		{
			let plr = PlayerPawn(e.Thing.target);
			if (plr && ReadyWeapon)
			{
				ProjectileBinds.Insert(e.Thing.GetClassName(), ReadyWeapon.GetClassName());
			}
		}
	}

	// --------------------------------------------------
	// INITIALIZATION
	// --------------------------------------------------

	// [Ace] OnRegister is called when save games are loaded.
	override void OnRegister()
	{
		WeaponStorage = CVar.FindCVar("wt_stats_weapons_kills");
		ExperienceStorage = CVar.FindCVar('wt_stats_experience');
		PrestigeStorage = CVar.FindCVar('wt_stats_prestige');

		IWADWeaponFilter = CVar.FindCVar('wt_filter_iwad_weapons');
		IWADMonsterFilter = CVar.FindCVar('wt_filter_iwad_monsters');

		ScorecardScale = CVar.FindCVar('wt_scorecard_scale');
		BlackDisplay = CVar.FindCVar('wt_scorecard_blackdisplays');

		LiteHudType = CVar.FindCVar('wt_showlite');
		LiteHudOrientation = CVar.FindCVar('wt_lite_orientation');
		LiteHudScale = CVar.FindCVar('wt_lite_scale');
		LiteHudOffsetX = CVar.FindCVar('wt_lite_offset_x');
		LiteHudOffsetY = CVar.FindCVar('wt_lite_offset_y');
		LiteHudAlpha = CVar.FindCVar('wt_lite_alpha');
		LiteFolderView = CVar.FindCVar('wt_lite_usefolders');
		LiteHudColors[Color_Labels] = CVar.FindCVar('wt_lite_color_labels');
		LiteHudColors[Color_TotalKills] = CVar.FindCVar('wt_lite_color_totalkills');
		LiteHudColors[Color_GenocideRank] = CVar.FindCVar('wt_lite_color_genociderank');
		LiteHudColors[Color_PlayerRank] = CVar.FindCVar('wt_lite_color_playerrank');
		LiteHudColors[Color_WeaponName] = CVar.FindCVar('wt_lite_color_weaponname');
		LiteHudColors[Color_WeaponRank] = CVar.FindCVar('wt_lite_color_weaponrank');
		LiteHudColors[Color_WeaponKills] = CVar.FindCVar('wt_lite_color_weaponkills');
		LiteHudVisibilityFlags = CVar.FindCVar('wt_lite_adv_visibility');

		KillSoundType = CVar.FindCVar('wt_killsound');
		BlacklistEnabled = CVar.FindCVar('wt_blacklist_enable');

		Initialize(false);
	}

	void Initialize(bool reset)
	{
		FolderInit();
		ProjectileBinds = Dictionary.Create();

		if (reset)
		{
			WeaponStorage.ResetToDefault();
			ExperienceStorage.ResetToDefault();
			PrestigeStorage.ResetToDefault();

			WeaponStats = Dictionary.Create();
			Experience = 0;
			Prestige = 0;
		}
		else
		{
			WeaponStats = Dictionary.FromString(WeaponStorage.GetString());
			Experience = ExperienceStorage.GetInt();
			Prestige = PrestigeStorage.GetInt();
		}

		NeedsUpdating = Update_All;
	}

	// --------------------------------------------------
	// VARIABLE UPDATES & OTHER
	// --------------------------------------------------

	override void WorldTick()
	{
		// [Ace] 10 tics should be enough so that SetString doesn't shit the bed.
		if (!DisableSaving && WeaponStats && level.time % 10 == 0)
		{
			WeaponStorage.SetString(WeaponStats.ToString());
			ExperienceStorage.SetInt(Experience);
			PrestigeStorage.SetInt(Prestige);
		}

		// [Ace] Update weapon.
		if (level.time % 2 == 0)
		{
			// [Ace] This will desync. You have been warned. I have been warned.
			let plr = PlayerPawn(players[consoleplayer].mo);
			if (plr && plr.player && plr.player.ReadyWeapon)
			{
				class<Weapon> OldWeapon = ReadyWeapon;

				// [Ace] If the weapon is a powered up version, use the main one instead.
				ReadyWeapon = plr.player.ReadyWeapon.bPOWERED_UP ? plr.Player.ReadyWeapon.SisterWeaponType : plr.player.ReadyWeapon.GetClass();

				// [Ace] Checks if the weapon selection has changed. Also update the scorecard upon opening it because of autoselect, otherwise the wrong stats will be displayed.
				if (ReadyWeapon != OldWeapon)
				{
					NeedsUpdating |= Update_Lite | Update_Scorecard_Main;
				} 
			}
		}
	}

	override void WorldUnloaded(WorldEvent e)
	{
		IsUiProcessor = false;
		DrawUi = false;
	}

	// --------------------------------------------------
	// PROGRESS ERASING
	// --------------------------------------------------

	private void ResetTally()
	{
		Initialize(true);
		Console.Printf("All statistics successfully reset!");
	}

	private void ResetWeapon()
	{
		if (WeaponStats)
		{
			WeaponStats.Remove(ReadyWeapon.GetClassName());
		}
		Console.Printf("Weapon statistics successfully reset!");
	}

	// --------------------------------------------------
	// MISCELLANEOUS
	// --------------------------------------------------

	override void NetworkProcess(ConsoleEvent e)
	{
		if (e.Name ~== "WT_ResetTally")
		{
			ResetTally();
			NeedsUpdating = Update_All;
		}

		if (e.Name ~== "WT_ResetWeapon")
		{
			ResetWeapon();
			NeedsUpdating = Update_All;
		}

		if (e.Name ~== "WT_ToggleUI")
		{
			DrawUi = !DrawUi;
			self.IsUiProcessor = !self.IsUiProcessor;
			S_StartSound(DrawUi ? "WT/ScorecardOpen" : "WT/ScorecardClose", CHAN_AUTO, CHANF_UI | CHANF_LOCAL);
		}

		if (e.Name ~== "WT_UpgradePrestige")
		{
			UpgradePrestige();
		}

		if (e.Name ~== "WT_ToggleSaving")
		{
			DisableSaving = !DisableSaving;
			if (!DisableSaving)
			{
				Initialize(false);
			}
			Console.Printf("Kill saving "..(DisableSaving ? "disabled" : "enabled")..".");
		}

		// [Ace] These are here if they need to be called from UI scope.
		if (e.Name ~== "WT_MarkUpdated")
		{
			NeedsUpdating &= ~e.Args[0];
		}

		if (e.Name ~== "WT_MarkNotUpdated")
		{
			NeedsUpdating |= e.Args[0];
		}

		if (e.Name ~== "WT_FolderInit")
		{
			FolderInit();
		}
	}
}